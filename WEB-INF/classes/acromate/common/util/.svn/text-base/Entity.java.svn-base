package	acromate.common.util;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.Vector;
import java.util.Set;
import java.util.Map;
import java.util.Enumeration;
import java.util.ArrayList;

import java.text.SimpleDateFormat;
import java.text.ParsePosition;

import java.math.BigDecimal;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

import java.io.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.ServletException;

/**
 *  Entity - 데이터 표현 HashMap
 */
public class Entity extends HashMap{

    /**
     *  parseResultSet - ResultSet 에서 컬럼 이름을 key로 해서 그 값을 Entity 에 저장하는 method
     *
     *  @param  ResultSet   ResultSet 객체
     *  @return N/A
     */
    public void parseResultSet(ResultSet rs) throws SQLException {
        try {
            ResultSetMetaData md = rs.getMetaData();
            int size = md.getColumnCount();

            for (int i = 1; i <= size; i++) {
                if (!md.getColumnTypeName(i).equals("CLOB") ) {         // clob이 아닌 일반 String일 경우..
                    setValue(md.getColumnName(i), rs.getString(i));
                } else {                                                // clob검색시 ..
                    String sColumnName = md.getColumnName(i);
                    Reader rd = rs.getCharacterStream(sColumnName);
                    StringBuffer sb = new StringBuffer();
                    char[] buf = new char[1024];
                    int readcnt;
                    try {
                        while ((readcnt = rd.read(buf, 0, 1024)) != -1) {
                            // 스트림으로부터 읽어서 스트링 버퍼에 넣는다.
                            sb.append(buf, 0, readcnt);
                            setValue(md.getColumnName(i), sb.toString());
                        }
                    } catch(Exception clobe) {
                    } finally {
                        rd.close();
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

	/**
	 *  parseResultSet - ResultSet 에서 컬럼 이름을 key로 해서 그 값을 Entity 에 저장하는 method
	 *
	 *  @param  ResultSet   ResultSet 객체
	 *  @return N/A
	 */
	public void parseResultSetNotNull(ResultSet rs) throws SQLException {
		try {
			ResultSetMetaData md = rs.getMetaData();
			int size = md.getColumnCount();

			for (int i = 1; i <= size; i++) {
				setValueNotNull(md.getColumnName(i), rs.getString(i));
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

    /**
     *  parseResultSet - ResultSet 에서 컬럼 이름과 인덱스를 key로 해서 그 값을 Entity 에 저장하는 method
     *
     *  @param  int         iIndex
     *  @param  ResultSet   rs
     *  @return N/A
     */
    public void parseResultSet(int iIndex, ResultSet rs) throws SQLException {
        ResultSetMetaData md = rs.getMetaData();
        int size = md.getColumnCount();

        String sColumnName = null;
        String sColumnValue = null;
        for (int i = 1; i <= size; i++) {
            setValue(new StringBuffer(md.getColumnName(i)).append(iIndex).toString(), rs.getString(i));
        }
    }

    /**
     *  parseRequest - Request 에서 parameter 를 뽑아서 Entity 에 저정하는 method
     *
     *  @param  HttpServletRequest
     *  @return N/A
     */
    public void parseRequest(HttpServletRequest pm_oRequest) throws ServletException {

        Enumeration im_oEnum    = pm_oRequest.getParameterNames();
        String      im_sParam   = null;
        String[]    im_sValues  = null;

        while (im_oEnum.hasMoreElements()) {
            im_sParam = (String) im_oEnum.nextElement();                    //formField의 Name을 받음
            im_sValues = pm_oRequest.getParameterValues(im_sParam);

            if (im_sValues.length == 1) {
                setValue(im_sParam, im_sValues[0]);
            } else {
                setValue(im_sParam, im_sValues);
            }
        }
    }

	public void setValue(String sKey, String sValue) {
		if (sValue != null) put(sKey.toUpperCase(), sValue);
	}

	public void setValueNotNull(String sKey, String sValue) {
		if (sValue == null) put(sKey.toUpperCase(), "");
		else put(sKey.toUpperCase(), sValue);
	}
	    

    public void setValue(String sKey, String sValues[]) {
        put(sKey.toUpperCase(), sValues);
    }

    public void setValue(String sKey, byte[] yValues) {
        String sValue = null;

        if (yValues != null) sValue = new String(yValues);
        put(sKey.toUpperCase(), sValue);
    }

    public void setValue(String sKey, byte yValue) {
        put(sKey.toUpperCase(), Byte.toString(yValue));
    }

    public void setValue(String sKey, char[] cValues) {
        String sValue = null;

        if (cValues != null) sValue = new String(cValues);
        put(sKey.toUpperCase(), sValue);
    }

    public void setValue(String sKey, char cValue) {
        put(sKey.toUpperCase(), String.valueOf(cValue));
    }

    public void setValue(String sKey, float fValue) {
        put(sKey.toUpperCase(), String.valueOf(fValue));
    }

    public void setValue(String sKey, boolean bValue) {
        put(sKey.toUpperCase(), String.valueOf(bValue));
    }

    public void setValue(String sKey, short tValue) {
        put(sKey.toUpperCase(), String.valueOf(tValue));
    }

    public void setValue(String sKey, int iValue) {
        put(sKey.toUpperCase(), String.valueOf(iValue));
    }

    public void setValue(String sKey, long lValue) {
        put(sKey.toUpperCase(), String.valueOf(lValue));
    }

    public void setValue(String sKey, double dValue) {
        put(sKey.toUpperCase(), String.valueOf(dValue));
    }

    public void setValue(String sKey, BigDecimal bValue) {
        put(sKey.toUpperCase(), String.valueOf(bValue));
    }

    public void setValue(String sKey, java.util.Date value) {
        String sValue = null;

        if (value != null) sValue = value.toString();
        put(sKey.toUpperCase(), sValue);
    }

    public void setValue(String sKey, Vector value) {
        put(sKey.toUpperCase(), value);
    }

    public void setValue(String sKey, ArrayList value) {
        put(sKey.toUpperCase(), value);
    }

    public void setValue(String sKey, Hashtable value) {
        put(sKey.toUpperCase(), value);
    }

    public void setValue(String sKey, Entity value) {
        put(sKey.toUpperCase(), value);
    }

    public void setValue(String sKey, HashMap value) {
        put(sKey.toUpperCase(), value);
    }

    public String getString(String sKey) {
        String sValue = null;
        Object obj = null;

        try {
            obj = get(sKey.toUpperCase());
            if (obj instanceof String) {
                sValue = (String) obj;
            } else if (obj instanceof String[]) {
                sValue = ((String[]) obj)[0];
            } else {
                sValue = "";
            }
        } catch (Exception e) {
            sValue = "";
        }

        return sValue;
    }

    /**
     *  getStrings - Entity 에 저장된 String[] 를 return 하는 method
     *               String 이 저장되어 있을 경우에는 length 가 1인 String[] 를 return 한다.
     *
     *  @param  String sKey
     *  @return String[]
     */
    public String[] getStrings(String sKey) {
        String sValues[] = null;
        Object obj = null;

        try {
            obj = get(sKey.toUpperCase());

            if (obj instanceof String) {
                sValues = new String[1];
                sValues[0] = (String) obj;
            } else {
                sValues = (String[])obj;
            }
        } catch (Exception e) {
        }
        return sValues;
    }

    public byte getByte(String sKey) {
        byte yResult = (byte)0;

        try {
            yResult = Byte.parseByte((String)get(sKey.toUpperCase()));
        } catch (Exception e) {
        }

        return yResult;
    }

    public byte[] getBytes(String sKey) {
        byte[] yResults = null;

        try {
            yResults = ((String)get(sKey.toUpperCase())).getBytes();
        } catch (Exception e) {
        }

        return yResults;
    }

    public char getChar(String sKey) {
        char cResult = (char)0;

        try {
            cResult = ((String)get(sKey.toUpperCase())).charAt(0);
        } catch (Exception e) {
        }

        return cResult;
    }

    public char[] getChars(String sKey) {
        char[] cResults = null;

        try {
            cResults = ((String)get(sKey.toUpperCase())).toCharArray();
        } catch (Exception e) {
        }

        return cResults;
    }

    public float getFloat(String sKey) {
        float fResult = 0;

        try {
            fResult = Float.parseFloat((String)get(sKey.toUpperCase()));
        } catch (Exception e) {
        }

        return fResult;
    }

    public boolean getBoolean(String sKey) {
        boolean bResult = false;

        try {
            bResult = Boolean.getBoolean((String)get(sKey.toUpperCase()));
        } catch (Exception e) {
        }

        return bResult;
    }

    public short getShort(String sKey) {
        short tResult = 0;

        try {
            tResult = Short.parseShort((String)get(sKey.toUpperCase()));
        } catch (Exception e) {
        }

        return tResult;
    }

    public int getInt(String sKey) {
        int iResult = 0;

        try {
            iResult = Integer.parseInt((String)get(sKey.toUpperCase()));
        } catch (Exception e) {
        }

        return iResult;
    }

    public long getLong(String sKey) {
        long lResult = 0;

        try {
            lResult = Long.parseLong((String)get(sKey.toUpperCase()));
        } catch (Exception e) {
        }

        return lResult;
    }

    public double getDouble(String sKey) {
        double dResult = 0;

        try {
            dResult = Double.parseDouble((String)get(sKey.toUpperCase()));
        } catch (Exception e) {
        }

        return dResult;
    }

    public BigDecimal getBigDecimal(String sKey) {
        BigDecimal bResult  = new BigDecimal("0");

        try {
            bResult = new BigDecimal((String)get(sKey.toUpperCase()));
        } catch (Exception e) {
        }

        return bResult;
    }

    public java.util.Date getDate(String sKey) {
        java.util.Date result = null;

        try {
            String sDate = (String)get(sKey.toUpperCase());
            SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
            ParsePosition pos = new ParsePosition(0);
            result = formatter.parse(sDate, pos);
        } catch (Exception e) {
        }

        return result;
    }

    public Vector getVector(String sKey) {
        Vector vResult = null;

        try {
            vResult = (Vector)get(sKey.toUpperCase());
        } catch (Exception e) {
        }

        return vResult;
    }

    public ArrayList getArrayList(String sKey) {
        ArrayList alResult = null;

        try {
            alResult = (ArrayList)get(sKey.toUpperCase());
        } catch (Exception e) {
        }

        return alResult;
    }

    public Hashtable getHashtable(String sKey) {
        Hashtable value = null;

        try {
            value = (Hashtable)get(sKey.toUpperCase());
            if (value == null)
                value = new Hashtable();
        } catch (Exception e) {
            value = new Hashtable();
        }

        return value;
    }

    public Entity getEntity(String sKey) {
        Entity value = null;

        try {
            value = (Entity)get(sKey.toUpperCase());
            if (value == null)
                value = new Entity();
        } catch (Exception e) {
            value = new Entity();
        }

        return value;
    }

    public HashMap getHashMap(String sKey) {
        HashMap value = null;

        try {
            value = (HashMap)get(sKey.toUpperCase());
            if (value == null)
                value = new HashMap();
        } catch (Exception e) {
            value = new HashMap();
        }

        return value;
    }

    public void removeValue(String sKey) {
        remove(sKey.toUpperCase());
    }

    public String getKey(String sValue) {
        String sResult = null;

        Set keySet = entrySet();
        Object lists[] = keySet.toArray();

        String sKey = null;
        Object value = null;
        for (int i = 0; i < lists.length; i++) {
            sKey = (String)(((Map.Entry)lists[i]).getKey());
            value = get(sKey);
            if (value instanceof String && ((String)value).trim().equals(sValue)) {
                sResult = (String)sKey;
                break;
            }
        }

        return sResult;
    }

    public String getKey(String sValue, String sKeyPrefix) {
        sKeyPrefix = sKeyPrefix.toUpperCase();

        String sResult = null;

        Set keySet = entrySet();
        Object lists[] = keySet.toArray();

        String sKey = null;
        Object value = null;
        for (int i = 0; i < lists.length; i++) {
            sKey = (String)(((Map.Entry)lists[i]).getKey());
            value = get(sKey);
            if (sKey.startsWith(sKeyPrefix) && value instanceof String && ((String)value).trim().equals(sValue)) {
                sResult = (String)sKey;
                break;
            }
        }

        return sResult;
    }
}
