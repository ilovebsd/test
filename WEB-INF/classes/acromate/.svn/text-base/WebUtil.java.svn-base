package acromate;

import java.util.*;
import java.sql.*;

import java.awt.*;
import javax.swing.*;

import com.acromate.lang.l;

import java.text.SimpleDateFormat;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
//import javax.servlet.http.*;
/**
Web Utility Class
*/

public class WebUtil
{
        //프로토콜
        public static final int Common_H323 = 1;
        public static final int Common_SIP = 2;
        public static final int Common_MGCP = 3;
        public static final int Common_MEGACO = 4;
        public static final int Common_PSTN = 5;

	public static final int CALLDROP = 1;
	public static final int GKCONF = 2;
	public static final int EPUNREGISTER = 3;
	public static final int EPDATA = 4;
	public static final int ALIAS = 5;
	public static final int CDR = 6;
	public static final int GATEWAY = 7;
	public static final int NGK = 8;

	public static final int ERROR_GKNETWORK = 51;
	public static final int ERROR_NOTMANAGER = 52;
	public static final int ERROR_MANAGERLOGOUT = 53;
	public static final int ERROR_MANAGER_DUPLIACTE = 54;
	public static final int ERROR_CLIENT_DUPLIACTE = 55;
	public static final int ERROR_COOKIE_TIMEOUT = 56;
	public static final int ERROR_CONF_ALDY_REQ = 57;
	public static final int ERROR_EP_ALDY_UNREG = 58;
	public static final int ERROR_CALLDROP_ALDY_REQ = 59;

	public static final int ERROR_CLIENT_BROWSER = 71;
	public static final int ERROR_LOGTRACE = 72;

	public static final int INFO_EPUNREGISTER = 81;
	public static final int INFO_CALLDROP = 82;
	public static final int INFO_CALLDROP_REQ = 83;
	public static final int INFO_CONFSET = 84;
	public static final int INFO_EP_UNREG_REQ = 85;

	public static final byte conCheckIP=(byte)0x10;
	public static final byte conCheckPasswd=(byte)0x20;
	public static final byte conCheckE164=(byte)0x40;
        public static final byte conCheckID=(byte)0x40;
        public static final byte conCheckDomain=(byte)0x40;
        public static final byte conCheckEPclass=(byte)0x20;
        public static final int conP_AcertedIdentity=128;

        public static final byte conCheckSIPProxy=(byte)0x28;
        public static final byte conCheckSIPTGW=(byte)0x24;
        public static final byte conCheckSIPTGWRegisetr=(byte)0x25;
        public static final byte conCheckSIP_IPPBXregister=(byte)0x23;

        public static final byte conCheckNeighborSSW=(byte)0x2A;
        public static final byte conCheckChannelGroup=(byte)0x58;

        public static final byte conCheckNotStart=(byte)0x00;
        public static final byte conCheckStart=(byte)0x01;

	public static final byte conCheckPasswdFirst=(byte)0x00;
	public static final byte conCheckPasswdChanged=(byte)0x00;
	public static final byte conCheckPasswdAnytime=(byte)0x04;
	public static final byte conCheckPasswd_RegisterIsAll_InviteIsChanged=(byte)0x03;
        public static final byte conCheckPasswd_Not_Certify_IP=(byte)0x00;
        public static final byte conCheckPasswd_IP_Changed_Reject=(byte)0x01;
        public static final byte conCheckPasswd_Invite_Anytime=(byte)0x02;
        public static final byte conCheckPasswd_Invite_IP_Changed=(byte)0x03;
        public static final byte conCheckIP_Port=(byte)0x08;

        public static final byte conCheckClassGK=(byte)0x18;
        public static final byte conCheckClassh323TGW=(byte)0x14;

        public static final byte conCheckClassh323TGWRegister=(byte)0x15;

        public static final byte conCheckEndpointID=(byte)0x01;
        public static final byte conCheckGKID=(byte)0x00;
        public static final byte conCheckSubID=(byte)0x01;

        public static final byte conCheckOutGKID=(byte)0x01;
        public static final byte conCheckOutH323ID=(byte)0x02;

        public static final byte conCheckLocalPrefix=(byte)0x01;
        public static final byte conCheckSpecialNum=(byte)0x02;
        public static final byte conCheckLocalPrefixIPPBX=(byte)0x03;
        public static final byte conCheckCallTermination=(byte)0x00;
        public static final byte conCheckCallTrnasRoute=(byte)0x10;
        public static final byte conCheckCallTrnasRouteGroup=(byte)0x20;
        public static final byte conCheckCallTrnasE164=(byte)0x30;
        public static final byte conCheckCallTransNum=(byte)0x40;
//        public static final byte conCheckSubcriberorPhone=(byte)0x000;
//        public static final byte conCheckPhoneError=(byte)0x100;
//        public static final byte conCheckSubcriberError=(byte)0x200;
    //### Authmode를 위한 값------------------------------------------------------
        //P-Aserted인증
        public static final int conCheckAuth_P_Aserted_Use = 8192;
        public static final int conCheckAuth_P_Aserted_NotUse = 0;
        //Message인증
        public static final int conCheckAuth_MessageAuth_Invite = 4096;
        public static final int conCheckAuth_MessageAuth_All = 0;
        //Phone Number (E164, LRQ 인증)
        public static final int conCheckAuth_Phone_Num_Use = 2048;
        public static final int conCheckAuth_Phone_Num_NotUse = 0;
        //Via Domain or LRQ ID 인증
        public static final int conCheckAuth_Via_Domain_Use = 512;
        public static final int conCheckAuth_Via_Domain_NotUse = 0;
        public static final int conCheckAuth_LRQ_ID_Use_More = 256;
        public static final int conCheckAuth_LRQ_ID_Use_One = 0;
        //Passwd인증
        public static final int conCheckAuth_Passwd_Use = 128;
        public static final int conCheckAuth_Passwd_NotUse = 0;
        public static final int conCheckAuth_Phone_Num_AKAUse = 4;

        public static final int conCheckAuth_Passwd_Register_IPchange = 64;
        public static final int conCheckAuth_Passwd_Register_AnyTime = 0;
        public static final int conCheckAuth_Passwd_Register_Stale = 8;

        public static final int conCheckAuth_Passwd_Invite_Uncheck = 0;
        public static final int conCheckAuth_Passwd_Invite_AnyTime = 16;
        public static final int conCheckAuth_Passwd_Invite_IPReject = 32;
        public static final int conCheckAuth_Passwd_Invite_IPchange = 48;
        public static final int conCheckAuth_Passwd_ARQ_SetUp = 8;
        public static final int conCheckAuth_Passwd_LRQ_Auth = 16;


        //IP인증
        public static final int conCheckAuth_IP_Use = 2;
        public static final int conCheckAuth_IP_NotUse = 0;
        //Port인증
        public static final int conCheckAuth_IP_Port_Use = 1;
        public static final int conCheckAuth_IP_Port_NotUse = 1;
//-----------------------------------------------------------------------------------

        //Block의 While/Black을 위한 값
        public static final int BLOCK_NONE = 0;
        public static final int BLOCK_WHILE = 1;
         public static final int BLOCK_WHILE_ALL = 13;
        public static final int BLOCK_BLACK = 3;
        public static final int BLOCK_BLACK_NOCID = 7;
        public static final int BLOCK_BLACK_OTHERFORMAT = 11;
        public static final int BLOCK_BLACK_NOCID_OTHERFORMAT = 15;

        //Block의 INOUTFLAG을 위한 값
        public static final int BLOCK_IN_CALLER = 0;
        public static final int BLOCK_IN_CALLEE = 1;
        public static final int BLOCK_OUT_CALLER = 2;
        public static final int BLOCK_OUT_CALLEE = 3;


        //ROOTBlock의 While/Black을 위한 값
        public static final int ROOT_BLOCK_NONE = 0;
        public static final int ROOT_BLOCK_WHILE = 1;
        public static final int ROOT_BLOCK_BLACK = 3;
        public static final int ROOT_BLOCK_BLACK_NOCID = 7;
        public static final int ROOT_BLOCK_BLACK_OTHERFORMAT = 11;
        public static final int ROOT_BLOCK_BLACK_NOCID_OTHERFORMAT = 15;

        //ROOTBlock의 INOUTFLAG을 위한 값
        public static final int ROOT_BLOCK_IN_CALLER = 0;
        public static final int ROOT_BLOCK_IN_CALLEE = 1;
        public static final int ROOT_BLOCK_OUT_CALLER = 2;

        //prefix의 white/black값
        public static final int BLACK_PREFIX = 0;
        public static final int WHITE_PREFIX = 1;

        /************************CommandChannel의 형식정의**********************/
        public static final char COMMAND_DIV = 0x18;
        public static final char PARAMS_DIV = 0x12;
        public static final char COMMAND_DEFAULT = 0;
        public static final int SETSSWCONFIG = 2;
        public static final int GET_SSW_TRANSACTION_LOG=4;
        public static final int GET_SSW_INFORMATION=5;
        public static final int GET_CIC_UPDATE=6;
        public static final int GET_File_UPLOAD=7;
        //MachineAgent에서 MachineID는 COMMANDDETAIL에 실어서 보낸다.
        public static final int GET_MACNINEAGENT_CONFIG=8;
        public static final int SET_MACNINEAGENT_CONFIG=9;
        public static final int RUN_MACNINEAGENT_PROCESS=10;

        public static final int GET_SYSTEMLOG_CATEGORI=12;
        //public static final int KILL_SOFTSWITCH=13;
        //public static final int RUN_SOFTSWITCH=14;
        public static final int GET_PROCESS_CHANGE=15;
        public static final int GET_PROCESS_RECOVER=16;
        public static final int PROCESS_CHANGE=17;
        public static final int PROCESS_RECOVER=18;
        public static final int GET_PROCESS_VERSION=20;
        public static final int GET_CURRENT_CALL=22;

        public static final int RECOVER_DATABASE_EMS_FAST=50;
        public static final int RECOVER_DATABASE_EMS_NORMAL=51;
        public static final int RECOVER_DATABASE_SSW_FAST=52;
        public static final int RECOVER_DATABASE_SSW_NORMAL=53;

        public static final int GET_MACHINEAGENT_NTP = 55;
        public static final int SET_MACHINEAGENT_NTP = 56;

        /**프로세스관리 killprocess, runprocess*/
        public static final int KILL_PROCESS_PERMANENT = 55;
        public static final int RUN_PROCESS_PERMANENT = 56;
        //SSW 운용자에 의한 절체 명령
        public static final int SET_ACTIVE_CHANGE=21;

         //SSW 단말  UNREGISTER
       public static final int SET_ENDPOINT_UNREGISTER=30;
         //SSW Call Drop
       public static final int SET_CLL_DROP=31;
         //SSW Endpoint UPDATE
       public static final int SET_ENDPOINT_UPDATE=32;

       //SSW  동적 모듈 관리
       public static final int SET_LOAD_MODULE=33;
       public static final int SET_UNLOAD_MODULE=34;


       //해당path에 있는 파일리스트 전송
       public static final int GET_FILELIST_IN_DIR = 40;
       public static final int GET_FILELIST_IN_DIR_FROMSSW = 41;
       //EMS Schedule Thread runOnce
       public static final int RUN_SCHEDULE_THREAD_ONCE = 43;
       //EMS Active 변경
       public static final int EMS_ACTIVATE = 44;

       /*********************CommandChannel의 형식정의 END**********************/

        //서버간 통신을 위한 메세지 형식 정의
        //MESSAGE TYPE
        public static final int OPERATION = 4;
        public static final int INFORMATION = 0;
        public static final int FAULT = 1;
        public static final int ALARM = 2;
        public static final int INFORMATION_SSW = 0;
        public static final int INFORMATION_EMS = 6;
        public static final int SYSTEM_DATA_RESET = 0;

        //메세지코드정의
        public static final int CODE_NONE = 0;
        public static final int CODE_INFO = 1;
        public static final int CODE_FAULT = 2;
        public static final int CODE_ALARM_MINOR = 4;
        public static final int CODE_ALARM_MAJOR = 8;
        public static final int CODE_ALARM_CRITICAL = 16;

        // ALARM LEVEL정의
        public static final int MINOR = 1;
        public static final int MAJOR = 2;
        public static final int CIRTICAL = 3;
        public static final int CRITICAL = 3;

        // ALARM TYPE 정의
        public static final int SYSTEM_ERROR = 1;
        public static final int TRAFFIC_ERROR = 2;
        public static final int GENERAL_ERROR = 3;

        // 과부하 타입 해당 장애의 코드값으로 정의
        public static final int OVERFLOW_CALL = 30008;
        public static final int OVERFLOW_CPU = 30004;
        public static final int OVERFLOW_MEM = 30003;
        public static final int OVERFLOW_HDD = 30005;
        public static final int OVERFLOW_PROCESS = 30002;

        //EMS 프로세스 주기 메뉴 구분
        public static final int DBBACKUP_PROCESS = 0;
        public static final int LOGDEL_PROCESS = 1;
        public static final int SYSTEM_PROCESS = 2;
        public static final int CALL_PROCESS = 3;
        public static final int IPPBX_PROCESS = 4;

        //EMS Error 정의
        public static final String MGR_CONNECT_ERROR = "0";
        public static final String NOT_EXIST_DIR = "10";
        public static final String NOT_EXIST_FILE = "11";

        //EndpointClass 정의
        public static final String HEXINDEC_H323IPPBX = "H323 IP-PBX";
        public static final String HEXINDEC_H323TGW = "H323 TGW";
        public static final String HEXINDEC_H323TGWRegister = "H323 TGW(Register)";
        public static final String HEXINDEC_H323GK = "H323 GK";
        public static final String HEXINDEC_SIPIPPBX = "SIP IP-PBX";
        public static final String HEXINDEC_SIPTGW = "SIP IP-PBX";
        public static final String HEXINDEC_SIPTGWRegister = "SIP TGW(Register";
        public static final String HEXINDEC_SIPPROXY = "SIP PROXY";

        //MESSAGE 형식
        // {|0|(MESSAGE TYPE)|(MESSAGE)|} 형식이다.
        // 가장 앞자리는 편의상 비워놓았으며 DEFAULT 0 이다.
        // 위 형식은 OPERATION, INFOMATION메세지일 경우이며
        // ALARM, FAULT메세지는 3번째자리 MESSAGE에서 분기한다.
        // ALARM, FAULT메세지 형식
        // {|0|(MESSAGE TYPE)|(ALARM_LEVEL)|(ALARM_TYPE)|(ALARM_CODE)|(ALARM_NAME)|(ALARM_MESSAGE)|}
        // 추가 분류는 추후에 한다.

        // 통계 검색 출력 시간 타입 정의
        public static final int PERIOD_TIME = 1;
        public static final int PERIOD_DAY = 2;
        public static final int PERIOD_WEEK = 3;
        public static final int PERIOD_MONTH = 4;
        public static final int ZONE_TIME = 10;

        /**load Configration*/
        public static final boolean isSIU = false;
        public static final boolean isSBC = true;
        public static final boolean isEMS = false;
        public static final boolean isFullSet = true;


        //condor-20070122
        public static final int LOGIN_COMPLETE = 1;
        public static final int LOGIN_ERROR = 0;
        public static final int LOGIN_INVALID_USERID = -1;
        public static final int LOGIN_INVALID_PASSWORD = -2;
        public static final int LOGIN_DUPLICATE_USERID = -3;

        //condor-20070131
        public static final int LOGIN_DB_ERROR = -4;
        public static final int LOGIN_FAIL_EXCEPTION = -5;
        public static final int LOGIN_APICALL_EXCEPTION = -6;

        public static final int EDIT_DETAIL = 0;
        public static final int EDIT_INSERT = 1;
        public static final int EDIT_UPDATE = 2;


        public static boolean getBooleanProperty(Properties properties, String key, String defaultValue)
        {
		Object value = properties.getProperty(key, defaultValue);

		if (value == null)
		{	System.out.println("boolean property " + key + " does not exist");
			return false;
		}
		if (value instanceof String)
		{	String v = (String) value;
			if (v.equalsIgnoreCase("true"))
			return true;
			if (v.equalsIgnoreCase("false"))
			return false;
			if (v.equalsIgnoreCase("t"))
			return true;
			if (v.equalsIgnoreCase("f"))
			return false;
			System.out.println("unknown string value '" + v + "' for boolean property");
			return false;
		}
		if (value instanceof Boolean)
		return ((Boolean)value).booleanValue();

		System.out.println("illegal property type: " + value.getClass().getName());
		return false;
        }

	public static void MessageDialog(JFrame jframe, String strMessage, int type){
		JOptionPane.showOptionDialog( null, strMessage,l.x("확인","Confirm"), JOptionPane.OK_OPTION, type, null, new String[]{l.x("확인","OK")}, l.x("확인","OK"));
/*

		//JDialog 에 JOptionPane 을 담는다.
		final JDialog dialog = new JDialog(jframe, false); // true 시 모달 , false 시 모달리스
		dialog.setContentPane(optionPane); //담기
		optionPane.addPropertyChangeListener(new PropertyChangeListener(){
			public void propertyChange(PropertyChangeEvent e){
				if ( dialog.isVisible() && (e.getSource() == optionPane) ){
					dialog.setVisible(false);
				}
			}
		});
		dialog.pack();
		dialog.setLocationRelativeTo(MainFrame.getMainFrame());
		dialog.setVisible(true);*/
	}
	public static void MessageDialog(String strMessage, boolean isSuccess){
		if (isSuccess== true)
                    JOptionPane.showOptionDialog(null, strMessage,l.x("성공","Success"), JOptionPane.OK_OPTION, JOptionPane.PLAIN_MESSAGE, null, new String[]{l.x("확인","OK")}, l.x("확인","OK"));
                else
                    JOptionPane.showOptionDialog(null, strMessage,l.x("경고","Warning"), JOptionPane.OK_OPTION, JOptionPane.WARNING_MESSAGE, null, new String[]{l.x("확인","OK")}, l.x("확인","OK"));
	}
	public static int ConfirmMessageDialog(String strMessage){
              int returnValue = JOptionPane.showOptionDialog(null, strMessage, l.x("확인","Confirm"),
			  	JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new String[] {l.x("확인","OK"), l.x("취소","Cancel")}, l.x("확인","OK"));
                      return returnValue;
	}
	/* Color ***********************************/
	public static Color GetColorWorkPanel(){
		return (new Color(242,242,242));
	}
	/******************************************/
	public static String GetInformationMessage(int nWarningCode, String strKey)
	{
		String strWarningMessage = "";
		switch (nWarningCode)
		{
			case INFO_EP_UNREG_REQ :
				strWarningMessage = "정상적으로 SoftSwitch에 <b> " + strKey + "</b>를 Unregister 요청 하였습니다.";
				break;
			case INFO_CALLDROP_REQ :
				strWarningMessage = "정상적으로 SoftSwitch에 <b> " + strKey + "</b>를 Call Drop 요청 하였습니다.";
				break;
		}
		return strWarningMessage;
	}

	public static String GetInformationMessage(int nWarningCode)
	{
		String strWarningMessage = "";
		switch (nWarningCode)
		{
			case INFO_CALLDROP :
				strWarningMessage = "Call Drop에 대해서는 SoftSwitch의 상황에 따라서 즉시 반영되지 않을 수도 있습니다.";
				break;
			case INFO_EPUNREGISTER :
				strWarningMessage = "EndPoint Unregister에 대해서는 SoftSwitch의 상황에 따라서 즉시 반영되지 않을 수도 있습니다.";
				break;
			case INFO_CONFSET :
				strWarningMessage = "정상적으로 SoftSwitch에 <b>환경설정</b>을 변경 요청 하였습니다.";
				break;
		}
		return strWarningMessage;
	}

	public static String GetErrorMessage(int nErrorCode)
	{
		String strErrorMsg = "";
		switch (nErrorCode)
		{
			case ERROR_GKNETWORK:
				strErrorMsg = "SoftSwitch와의 Network 연결이 종료되었습니다.  SoftSwitch가 작동중이지 않거나 Network 연결설정 오류입니다.";
				break;
			case ERROR_NOTMANAGER:
				strErrorMsg = "등록된 관리자가 아닙니다. 관리자 ID와 암호를 정확하게 입력하시고 다시한번 시도해 주시기 바랍니다.";
				break;
			case ERROR_MANAGERLOGOUT:
				strErrorMsg = "로그아웃된 상태 이거나 Admin 관리자가 접속을 끊었습니다.";
				break;
			case ERROR_CLIENT_BROWSER:
				strErrorMsg = "Microsoft Internet Explorer 5.5 이상에서만 사용 가능합니다.";
				break;
			case ERROR_LOGTRACE:
				strErrorMsg = "귀하의 운영체제의 버전으로는 SoftSwitch의 실시간 메시지를 Trace할 수 없습니다.<br>";
				strErrorMsg += "(사용 가능한 운영체제는 Windows NT계열, Windows 2000계열, Windows XP계열, Windows2003입니다.)";
				break;
			case ERROR_MANAGER_DUPLIACTE:
				strErrorMsg = "다른 클라이언트에서 로그인을 하고 로그아웃을 하지 않았으므로 현재의 클라이언트에서 로그인할 수 없습니다.<br>";
				strErrorMsg += "(서로 다른 PC라고 하더라도 Dacom SSW Management System 에서 웹 로그인을 했을 경우 반드시 로그 아웃을 하셔야 합니다.)";
				break;
			case ERROR_CLIENT_DUPLIACTE:
				strErrorMsg = "같은 PC에서 SoftSwitch Web Management System에 두번 로그인 할 수 없습니다.<br>";
				strErrorMsg += "(이미 로그인한 Web Browser를 로그아웃 하시고 난 후에 다시 로그인 하시기 바랍니다.)";
				break;
			case ERROR_COOKIE_TIMEOUT:
				strErrorMsg = "로그인한 뒤 1일동안 사용하지 않으셨습니다. 다시한번 로그인을 해주시기 바랍니다.<br>";
				break;
		}
		return strErrorMsg;
	}

	public static String GetErrorMessage(int nErrorCode, String strKey)
	{
		String strErrorMsg = "";
		switch (nErrorCode)
		{
			case ERROR_CONF_ALDY_REQ :
				strErrorMsg = "환경변수 <b>" + strKey + "</b>번째 Field는 이미 SoftSwitch에 변경 요청된 상태입니다.";
				break;
			case ERROR_EP_ALDY_UNREG :
				strErrorMsg = "Endpoint ID <b>" + strKey + "</b>는 이미 Unregister 요청된 상태입니다.";
				break;
			case ERROR_CALLDROP_ALDY_REQ :
				strErrorMsg = "CallerID<b> " + strKey + "</b>는 이미 Call Drop 요청된 상태입니다.";
				break;
		}
		return strErrorMsg;
	}

	/**
	String Value Check
	*/


	public static String CheckNullString(String str)
	{
		String strReturn = "";
		if ((str == null) || ("".equals(str) == true))
			strReturn = "";
		else
			strReturn = str;
		return strReturn;
	}

	/**
	int Value Check
	*/
	public static int CheckNullInt(String str)
	{
		int nReturn = -1;
		if ((str == null) || ("".equals(str) == true))
			nReturn = 0;
		else
		{
			try
			{
				nReturn = Integer.parseInt(str);
			}
			catch(NumberFormatException e)
			{
				nReturn = -1;
			}
		}
		return nReturn;
	}

	public static String CheckSetNull(String str)
	{
		if(str==null) return null;
		if(str.length()==0) return null;
		return str ;
	}

	public static String getOrderString(int nOrder)
	{
		String strReturn;
		switch (nOrder)
		{
			case CALLDROP :
				strReturn = "Call Drop";
				break;
			case GKCONF :
				strReturn = "SSW Configure";
				break;
			case EPUNREGISTER :
				strReturn = "EndPoint Unregister";
				break;
			case EPDATA :
				strReturn = "EndPoint Data";
				break;
			case ALIAS :
				strReturn = "EndPoint Alias Value";
				break;
			case CDR :
				strReturn = "CDR";
				break;
			case GATEWAY :
				strReturn = "Gateway";
				break;
			case NGK :
				strReturn = "Neighbor Gateway";
				break;
			default :
				strReturn = "No Data Found";
				break;
		}
		return strReturn;
	}

	public static String getResultString(int nResult)
	{
		String strReturn = "";
		switch(nResult)
		{
			case 0 :
				strReturn = l.x("SSW 처리중","Continue...");
				break;
			case 1 :
				strReturn  = "Success";
				break;
			case 2 :
				strReturn = "Fail";
				break;
		}
		return strReturn;
	}
/*
       private static String ComvertTime(long date)
        {
                Calendar cal=Calendar.getInstance();
                cal.setTime(new	Date(date));

                StringBuffer sbuf=new StringBuffer();
                sbuf.append(cal.get(cal.YEAR));
                sbuf.append("-");
                sbuf.append(StringFormat.oo(cal.get(cal.MONTH)+1));
                sbuf.append("-");
                sbuf.append(StringFormat.oo(cal.get(cal.DAY_OF_MONTH)));
                sbuf.append(" ");
                sbuf.append(StringFormat.oo(cal.get(cal.HOUR_OF_DAY)));
                sbuf.append(":");
                sbuf.append(StringFormat.oo(cal.get(cal.MINUTE)));
                sbuf.append(":");
                sbuf.append(StringFormat.oo(cal.get(cal.SECOND)));

                return sbuf.toString();
	}
*/
	public static String ConvertMillisecondtoDateString(long lngMilli)
	{
		Calendar pCal = Calendar.getInstance() ;
                pCal.setTime(new	java.util.Date(lngMilli*1000)) ;
//		pCal.setTimeInMillis(lngMilli);
		String strDate = "";
		strDate = Integer.toString(pCal.get(Calendar.YEAR)) ;
		if ((pCal.get(Calendar.MONTH) + 1) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.MONTH) + 1) ;
		else
			strDate += Integer.toString(pCal.get(Calendar.MONTH) + 1) ;
		if (pCal.get(Calendar.DAY_OF_MONTH) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.DAY_OF_MONTH)) ;
		else
			strDate += Integer.toString(pCal.get(Calendar.DAY_OF_MONTH)) ;
		strDate += " ";
		if (pCal.get(Calendar.HOUR_OF_DAY) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.HOUR_OF_DAY)) ;
		else
			strDate += Integer.toString(pCal.get(Calendar.HOUR_OF_DAY)) ;
		strDate += ":";
		if (pCal.get(Calendar.MINUTE) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.MINUTE)) ;
		else
			strDate += Integer.toString(pCal.get(Calendar.MINUTE)) ;
		strDate += ":";
		if (pCal.get(Calendar.SECOND) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.SECOND));
		else
			strDate += Integer.toString(pCal.get(Calendar.SECOND));
		return strDate;
	}

        public static String ConvertMillisecondtoDateString_old(long lngMilli)
        {
          Calendar pCal = Calendar.getInstance();
          pCal.setTimeInMillis(lngMilli);
          String strDate = "";
          strDate = Integer.toString(pCal.get(Calendar.YEAR));
          if ((pCal.get(Calendar.MONTH) + 1) < 10)
                  strDate += "0" + Integer.toString(pCal.get(Calendar.MONTH) + 1);
          else
                  strDate += Integer.toString(pCal.get(Calendar.MONTH) + 1);
          if (pCal.get(Calendar.DAY_OF_MONTH) < 10)
                  strDate += "0" + Integer.toString(pCal.get(Calendar.DAY_OF_MONTH));
          else
                  strDate += Integer.toString(pCal.get(Calendar.DAY_OF_MONTH));
          strDate += " ";
          if (pCal.get(Calendar.HOUR_OF_DAY) < 10)
                  strDate += "0" + Integer.toString(pCal.get(Calendar.HOUR_OF_DAY));
          else
                  strDate += Integer.toString(pCal.get(Calendar.HOUR_OF_DAY));
          strDate += ":";
          if (pCal.get(Calendar.MINUTE) < 10)
                  strDate += "0" + Integer.toString(pCal.get(Calendar.MINUTE));
          else
                  strDate += Integer.toString(pCal.get(Calendar.MINUTE));
          strDate += ":";
          if (pCal.get(Calendar.SECOND) < 10)
                  strDate += "0" + Integer.toString(pCal.get(Calendar.SECOND));
          else
                  strDate += Integer.toString(pCal.get(Calendar.SECOND));
                return strDate;
	}

	public static String ConvertMillisecondtoDateString_YYYYMMDD(long lngMilli)
	{
		Calendar pCal = Calendar.getInstance();
		pCal.setTimeInMillis(lngMilli);
		String strDate = "";
		strDate = Integer.toString(pCal.get(Calendar.YEAR));
		if ((pCal.get(Calendar.MONTH) + 1) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.MONTH) + 1);
		else
			strDate += Integer.toString(pCal.get(Calendar.MONTH) + 1);
		if (pCal.get(Calendar.DAY_OF_MONTH) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.DAY_OF_MONTH));
		else
			strDate += Integer.toString(pCal.get(Calendar.DAY_OF_MONTH));
		return strDate;
	}

	public static String ConvertMillisecondtoDateString1(long lngMilli)
	{
		Calendar pCal = Calendar.getInstance();
		pCal.setTimeInMillis(lngMilli);
		String strDate = "";
		strDate = Integer.toString(pCal.get(Calendar.YEAR));
		if ((pCal.get(Calendar.MONTH) + 1) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.MONTH) + 1);
		else
			strDate += Integer.toString(pCal.get(Calendar.MONTH) + 1);
		if (pCal.get(Calendar.DAY_OF_MONTH) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.DAY_OF_MONTH));
		else
			strDate += Integer.toString(pCal.get(Calendar.DAY_OF_MONTH));
		strDate += "_";
		if (pCal.get(Calendar.HOUR_OF_DAY) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.HOUR_OF_DAY));
		else
			strDate += Integer.toString(pCal.get(Calendar.HOUR_OF_DAY));
		if (pCal.get(Calendar.MINUTE) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.MINUTE));
		else
			strDate += Integer.toString(pCal.get(Calendar.MINUTE));
		if (pCal.get(Calendar.SECOND) < 10)
			strDate += "0" + Integer.toString(pCal.get(Calendar.SECOND));
		else
			strDate += Integer.toString(pCal.get(Calendar.SECOND));
		return strDate;
	}

        public static String getYear(long lngMilli)
        {
                Calendar pCal = Calendar.getInstance();
                pCal.setTimeInMillis(lngMilli);
                String strDate = "";
                strDate = Integer.toString(pCal.get(Calendar.YEAR));

                return strDate;
	}
        public static String getMonth(long lngMilli)
        {
          Calendar pCal = Calendar.getInstance();
          pCal.setTimeInMillis(lngMilli);
          String strDate = "";
          if ((pCal.get(Calendar.MONTH) + 1) < 10)
                  strDate += "0" + Integer.toString(pCal.get(Calendar.MONTH) + 1);
          else
                  strDate += Integer.toString(pCal.get(Calendar.MONTH) + 1);
          return strDate;
	}
        public static String getDay(long lngMilli)
        {
          Calendar pCal = Calendar.getInstance();
          pCal.setTimeInMillis(lngMilli);
          String strDate = "";
          if (pCal.get(Calendar.DAY_OF_MONTH) < 10)
                  strDate += "0" + Integer.toString(pCal.get(Calendar.DAY_OF_MONTH));
          else
                  strDate += Integer.toString(pCal.get(Calendar.DAY_OF_MONTH));
          return strDate;
	}
        public static String getHour(long lngMilli)
        {
          Calendar pCal = Calendar.getInstance();
          pCal.setTimeInMillis(lngMilli);
          String strDate = "";
          if (pCal.get(Calendar.HOUR_OF_DAY) < 10)
                  strDate += "0" + Integer.toString(pCal.get(Calendar.HOUR_OF_DAY));
          else
                  strDate += Integer.toString(pCal.get(Calendar.HOUR_OF_DAY));
          return strDate;
	}
        public static String getMin(long lngMilli)
        {
          Calendar pCal = Calendar.getInstance();
          pCal.setTimeInMillis(lngMilli);
          String strDate = "";
          if (pCal.get(Calendar.MINUTE) < 10)
                  strDate += "0" + Integer.toString(pCal.get(Calendar.MINUTE));
          else
                  strDate += Integer.toString(pCal.get(Calendar.MINUTE));
          return strDate;
	}

        public static String getSec(long lngMilli) {
            Calendar pCal = Calendar.getInstance();
            pCal.setTimeInMillis(lngMilli);
            String strDate = "";
            if (pCal.get(Calendar.MINUTE) < 10)
                    strDate += "0" + Integer.toString(pCal.get(Calendar.SECOND));
            else
                    strDate += Integer.toString(pCal.get(Calendar.SECOND));
            return strDate;
        }

	public static int GetAmount(int nDuration, int nAccUnit, int nUnitChg)
	{
		int nAmount = 0;
		if (nAccUnit == 0) return 0;
		int nMok = (int) (nDuration / nAccUnit);
		int nNam = (int) (nDuration % nAccUnit);
		if (nNam == 0)
		{
			nAmount = nMok * nUnitChg;
		}
		else
		{
			nAmount = (nMok + 1) * nUnitChg;
		}
		return nAmount;
	}
	/**
	 *  현재 월의 마지막 일자
	 *  usage : DateUtil.getDaysOfMonth();
	 */
	public static int GetDaysOfMonth()
	{
		return Calendar.getInstance().getActualMaximum(Calendar.DAY_OF_MONTH);
	}

	/**
	 *  특정 월의 마지막 일자
	 *  usage : DateUtil.getDaysOfMonth( 2 ); // 2월의 마지막 날을 가져 올 때
	 */
	public static int GetDaysOfMonth(int vMonth)
	{
		int days = 0 ;

		if ( vMonth < 1 || vMonth > 12 ) vMonth = Calendar.getInstance().get(Calendar.MONTH)+1;

		switch ( vMonth )
		{
			case 1:	days=31;	break; // 1월
			case 2:	days=28;  days = ( Calendar.getInstance().get(Calendar.YEAR)%4 == 0 ) ? 29 : 28  ; 	break;  // 윤달 계산 4년에 한번
			case 3:	days=31;	break;
			case 4:	days=30;	break;
			case 5:	days=31;	break;
			case 6:	days=30;	break;
			case 7:	days=31;	break;
			case 8:	days=31;	break;
			case 9:	days=30;	break;
			case 10:	days=31;	break;
			case 11:	days=30;	break;
			case 12:	days=31;	break; // 12월
		}

		return days;
	}

	public static void println(Object object) {
		System.out.println(object);
	}
	public static void printErr(Object object) {
		System.out.println(object);
	}
	public static void printDebug(Object object) {
		System.out.println(object);
	}

//	public static ImageIcon createImageIcon(String file)
//	{
//		String path = "/image/" + file;
//		java.net.URL url = (acromate.MainFrame.class).getResource(path);
//		if(url != null)
//		{
//			return new ImageIcon(url);
//		} else
//		{
//			System.err.println("Couldn't find Image: " + path);
//			return null;
//		}
//	}
//	public static ImageIcon createImageIcon(String kor, String eng)
//	{
//		String path = "";
//		java.net.URL url = null;
//
//		if(l.langType == 0)
//		{
//			path = "/image/" + kor;
//		} else
//		{
//			path = "/image/" + eng;
//		}
//
//		url = (acromate.MainFrame.class).getResource(path);
//		if(url != null)
//		{
//			return new ImageIcon(url);
//		} else
//		{
//			System.err.println("Couldn't find Image: " + path);
//			return null;
//		}
//	}

        // 해당 스트링이 숫자인지를 검사하는 함수를 만들었음
        public static boolean isNumberFormat(String arg)
        {
          String strParam = arg;
          if("".equals(strParam)) return false;
          char[] ch_Param = strParam.toCharArray();
          for(int i=0;i<ch_Param.length;i++)
          {
            if(Character.isDigit(ch_Param[i])) continue;
            else return false;
          }
          return true;
        }
        //임의의 디폴트 객체를 Integer로 만드는 함수
        public static int convertToInt(Object obj){
          int nValue = 0;
          if (obj instanceof Boolean) {
            Boolean bBoolean = (Boolean) obj;
            if (bBoolean.booleanValue() == true) {
              nValue = 1;
            } else {
              nValue = 0;
            }
          } else if (obj instanceof Integer) {
            nValue = (Integer)obj;
          } else if (obj instanceof String) {
            nValue = Integer.parseInt( (String) obj);
          }
          return nValue;
       }
	  public static String setLimitQuery(Connection con)
	  {
		DatabaseMetaData databaseMetaData = null;
		String strDriver = "";
		String strLimitQuery = "";
		try {
			databaseMetaData = con.getMetaData();
			strDriver = databaseMetaData.getDriverName();
		} catch(Exception e){
			System.out.println("setLimitQuery Error : "+e.toString());
		}

		if (strDriver.toUpperCase().indexOf("ALTIBASE") >= 0) {
			strLimitQuery = " LIMIT 1,1 ";
		}
		else if (strDriver.toUpperCase().indexOf("MYSQL") >= 0) {
			strLimitQuery = " LIMIT 0,1 ";
		}
		else {
			strLimitQuery = " LIMIT 1,1 ";
			System.out.println("## setLimitQuery Error : Driver Name = "+strDriver);
		}

		return strLimitQuery;
	  }
          //SSW를 PROXY로 바꾸어 보여준다.
          public static String transferSSW2Proxy(String strMachineID){
              String MachineID = strMachineID.trim();
              if((MachineID != null) && ("".equals(MachineID) == false)){
                  if(MachineID.indexOf("SSW") > -1) MachineID = MachineID.replaceAll("SSW", "SSW");
              }
              return MachineID;
        }

        // 비트연산으로 현재 레벨을 얻어내는 함수
        public static int getRealAlarmLevel(int nLevel) {
            if ((nLevel & WebUtil.CODE_ALARM_CRITICAL) > 0) {
                return WebUtil.CRITICAL;
            }
            if ((nLevel & WebUtil.CODE_ALARM_MAJOR) > 0) {
                return WebUtil.MAJOR;
            }
            if ((nLevel & WebUtil.CODE_ALARM_MINOR) > 0) {
                return WebUtil.MINOR;
            }

            return 0;
        }
        //현재날짜로부터 nPeriod이전날짜 구하기
        public static String getDateBefore(int nDelLimit){
          Calendar cal = Calendar.getInstance();
          cal.add(Calendar.DATE, -nDelLimit); //nDelLimit일전
          java.util.Date currentTime = cal.getTime();
          SimpleDateFormat formatters1 = new SimpleDateFormat("yyyyMMdd");
          String Date = formatters1.format(currentTime);
          Date = Date.substring(0,4) + l.x( "년 ", "") + Date.substring(4,6)+l.x("월 ","")+Date.substring(6,8)+l.x("일","");
          return Date;
        }
        public static String getDateAfter(int nDelLimit){
            Calendar cal = Calendar.getInstance();
            cal.add(Calendar.DATE, nDelLimit); //nDelLimit일후
            java.util.Date currentTime = cal.getTime();
            SimpleDateFormat formatters1 = new SimpleDateFormat("yyyyMMdd");
            String Date = formatters1.format(currentTime);
            Date = Date.substring(0,4) + Date.substring(4,6)+ Date.substring(6,8);
            return Date;
          }
        //현재날짜로부터 nPeriod이전날짜 구하기
        public static String getMonthBefore(int nDelLimit){
          Calendar cal = Calendar.getInstance();
          cal.add(Calendar.MONTH, -nDelLimit); //nDelLimit달전
          java.util.Date currentTime = cal.getTime();
          SimpleDateFormat formatters1 = new SimpleDateFormat("yyyyMM");
          String Date = formatters1.format(currentTime);
          Date = Date.substring(0,4) + l.x( "년 ", "") + Date.substring(4,6)+l.x("월 ","");
          return Date;
        }

        //String->short
        public static short stringToshort(String arg){
            short sReturn = 0;
            if("".equals(arg)) return sReturn;
            try{
                sReturn = Short.parseShort(arg);
            }catch(Exception e){ sReturn = 0; }
            return sReturn;
        }
}
