package business;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class SmsAuthTicket {

	public static byte[] encrypto1(byte[] bytes) throws Exception {
		MessageDigest md = MessageDigest.getInstance("SHA1");

		md.update(bytes);

		byte[] hashBytes = md.digest();
		byte[] derivedKey = CryptDeriveKey(hashBytes, "SHA1", 24);

		return derivedKey;
	}

	 

	public static byte[] CryptDeriveKey(byte[] hBaseData, String hashAlgorithm, int requiredLength) {

		int keyLength = hBaseData.length;

		byte[] derivedKey = new byte[requiredLength];

		if(keyLength >= requiredLength) {

			for(int i = 0; i < requiredLength; i++) {

				derivedKey[i] = hBaseData[i];

			}
			return derivedKey;
		}

		byte[] buff1 = new byte[64];
		byte[] buff2 = new byte[64];

		Arrays.fill(buff1, (byte) 0x36);
		Arrays.fill(buff2, (byte) 0x5C);

		for(int i = 0; i < keyLength; i++) {
			buff1[i] ^= hBaseData[i];
			buff2[i] ^= hBaseData[i];
		}

		try {
			MessageDigest md = MessageDigest.getInstance(hashAlgorithm);

			md.reset();

			// use the named algorithm to hash those buffers

			byte[] result1 = md.digest(buff1);

			md.reset();

			byte[] result2 = md.digest(buff2);

			for(int i = 0; i < requiredLength; i++) {
				if(i < result1.length) {
					derivedKey[i] = result1[i];
				}
				else {
					derivedKey[i] = result2[i - result1.length];
				}
			}
		}catch(NoSuchAlgorithmException nsae) { }

		return derivedKey;

	}

	 

	public static String encrypto2(byte[] data1, byte[] data2) throws Exception {

		byte[] enc1 = encrypto1(data2);

		SecretKeySpec sks = new SecretKeySpec(enc1, 0, 16, "AES");

		byte[] iv = new byte[16];

		IvParameterSpec ivps = new IvParameterSpec(iv);

		Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");

		cipher.init(Cipher.ENCRYPT_MODE, sks, ivps);

		byte[] enc2 = cipher.doFinal(data1);
		
		char[] enc3 = Base64Coder.encode(enc2);
		
		
		return new String(enc3);

	}
		
}

