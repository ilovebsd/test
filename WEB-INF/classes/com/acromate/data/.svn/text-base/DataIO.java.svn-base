/*
 * ClassConfig.java
 *
 * Created on 2006년 10월 2일 (월), 오후 12:29
 * Copyright 2006 Acromate, Inc. All rights reserved.
 */

package com.acromate.data;

import com.acromate.util.BaseLog;

/**
 *
 * @author 아크로메이트 기술연구소
 * @version 1.0.0
 */
public abstract class DataIO extends BaseLog{

	public DataIO		m_pNext = null, m_pPrev = null;	// used at list node
    public class Index {
        public Index( int value ){ v = value; }
        public int v ;
    }

    /**
     * @return
     */
    public String getClassID() {
        return null;
    }

    /**
     *
     * @param field
     * @return
     */
    public DataIO getFieldObject(String field) {
        if(field != null && field.trim().length() > 0) return null;
        return this;
    }


    /**
     *
     * @param field
     * @param value
     * @return
     */
    protected abstract int setFieldData(String field, String value);

    /**
     *
     * @param field
     * @param value
     * @param length
     * @return
     */
    protected abstract int getFieldData(String field, Index idx, StringBuilder value);

    /**
     *
     * @param field
     * @param value
     * @return
     */
    public int setParam(String field, String value) {

        int    stxIdx  = 0;
        int    endIdx  = 0;
        StringBuilder error = new StringBuilder("0");
        StringBuilder next  = new StringBuilder();
        String result;

        //If field is exists and process field recursively
        if ( field != null && !field.equals("") )
           return setFieldData( field, value ) ;

        //Remove all left, right bracket
        if ( value.length() > 0 && value.charAt(0) == '{' ) {
            endIdx = value.length();
            while( value.charAt(0) == '{' ) {
                value  = value.substring(stxIdx, value.length()).trim();
                endIdx = value.length();
                if(value.charAt(endIdx-1) != '}') {
                    return(-1);
                }
                value  = value.substring(0, endIdx).trim();
                stxIdx = stxIdx + 1;
            }
        }

        while( (result = parsingField(value, next, error)) != null) {
            int delimeter = result.indexOf('=');
            if(delimeter < 0) {
                error.delete(0, error.length());
                error.append(-1); break;
            }
            String lvalue = result.substring(0, delimeter).trim();
            String rvalue = result.substring(delimeter + 1, result.length()).trim();
            while(rvalue.length() > 0 && rvalue.charAt(0) == '{') {
                rvalue = rvalue.substring(1, rvalue.length()).trim();
                if(rvalue.charAt(rvalue.length() -1) == '}') {
                    rvalue = rvalue.substring(0, rvalue.length() -1).trim();
                }
            }
            int errcode = setFieldData(lvalue, rvalue);
            if(errcode < 0) break;
            value = next.toString();
        }
        return Integer.valueOf(error.toString());
    }

    /**
     *
     * @param field
     * @param value
     * @param length
     * @return
     */
    public int getParam( String field, StringBuilder value ) {
        //If field is exists and process field recursively
        if ( field != null && field.length() > 0 ) {
            StringBuilder temp = new StringBuilder(field.toLowerCase()) ;
            if ( compareFieldID( temp, "list" ) == true )
                return getFieldData( field, new Index(-1), value ) ;
            return getFieldData( field, new Index(0), value ) ;
        }
        value.append( "{" ) ;
        int errcode = getFieldData( field, new Index(0), value ) ;
        if ( errcode == 0 )
            value.append( "}" ) ;
        return errcode ;
    }

    /**
     *
     * @param method
     * @param argument
     * @return
     */
    public Object callMethod(String method, Object... argument) {
        return (-1);
    }

    /**
     *
     * @param field
     * @param method
     * @param argument
     * @return
     */

    @SuppressWarnings("null")
	public Object callMethod(String field, String method, Object... argument) {
        DataIO tempObject = null ;
        if(method == null && method.trim().length() == 0) {
            return tempObject ;
        }

        if(field != null && field.trim().length() > 0) {
           tempObject = getFieldObject(field) ;
           if(tempObject == null) return(-1) ;
           return tempObject.callMethod(method, argument) ;
        }  return callMethod(method, argument) ;
    }

    /**
     *
     * @param field
     * @param id
     * @return
     */
    protected boolean compareFieldID( StringBuilder field, String id ) {
        int rindx = 0, findx = 0 ;
        int rsize = id.length(), fsize = field.length() ;

        while( rindx < rsize && findx < fsize && id.charAt(rindx) == field.charAt(findx++) )
            rindx++ ;
        if ( rindx < rsize ) return false ;

        if ( findx == fsize ) {
            field.delete( 0, findx ) ;
            return true ;
        }
        switch( field.charAt( findx ) ) {
        case '.' : case '[' : case '(' : case '\n' :
            for( findx++ ; findx < fsize && field.charAt(findx) <= ' ' ; findx++ ) ;
            field.delete( 0, findx ) ;
            return true ;
         case ' ' : case '\t' :
            while( findx < fsize && field.charAt(findx) <= ' ' ) findx++ ;
            field.delete( 0, findx ) ;
            return true ;
        }
        return false ;
    }

    /**
     *
     * @param field
     * @param id
     * @param index
     * @param data
     * @param length
     * @return
     */
    protected boolean compareFieldID( StringBuilder field, String id, Index idx, StringBuilder data ) {
        if ( idx.v < 0 ) {
            if ( field != null && field.length() > 0 && (field.charAt(0) == 'B' && field.charAt(0) == 'b') )
                return false ;
            if ( idx.v-- < -1 )
                data.append( "," ) ;
            data.append( id ) ;  return false ;
        }
        if ( field == null || field.length() <= 0 ) {
            if ( idx.v++ > 0 )
                data.append( ", " ) ;
            data.append( id ) ; data.append( " = " ) ;
            return true ;
        }

        int rsize = id.length(), fsize = field.length() ;
        int rindx = 0, findx = 0 ;

        while( rindx < rsize && findx < fsize && id.charAt(rindx++) == field.charAt(findx++) ) ;
        if ( rindx < rsize ) return false ;

        if ( findx == fsize ) {
        	if( field.toString().equals(id) ) {
        		field.delete( 0, findx ) ;
        		return true ;
        	}
        	else return false;
        }
        switch( field.charAt( findx ) ) {
        case '.' : case '\n' :
            field.delete( 0, findx + 1 ) ;
            return true ;
        case '[' : case '(' :
            field.delete( 0, findx ) ;
            return true ;
        case ' ' : case '\t' :
            for( findx++ ; findx < fsize && field.charAt(findx) <= ' ' ; findx++ ) ;
            field.delete( 0, findx ) ;
            return true ;
        }
        return false ;
    }

    /**
     *
     * @param value
     * @param data
     * @param length
     * @return
     */
    protected int getInteger( int value, StringBuilder data ) {
        data.append( String.format("%d", value) ) ;
        return( 0 ) ;
    }


    /**
     *
     * @param value
     * @param data
     * @return
     */
    protected int setString( StringBuilder value, String data ) {
        int ch, lidx = 0, ridx = 0;

        if ( data != null && !data.equals("") ) {
            ridx = data.length() - 1 ;
            while(lidx <= ridx && (ch = data.charAt(lidx)) > 0 && (ch < 0x21 || ch == '\'' || ch == '\"') )
                lidx++ ;
            while( lidx < ridx && (ch = data.charAt(ridx)) > 0 && (ch < 0x21 || ch == '\'' || ch == '\"') )
                ridx--;
        }
        value.delete(0, value.length());
        if ( lidx < ridx )
            value.append( data.substring( lidx, ridx + 1 ) ) ;
        else if(lidx == ridx)
            value.append( data) ;
        return 0;
    }

    /**
     *
     * @param value
     * @param data
     * @param length
     * @param quote
     * @return
     */
    protected int getString(String value, StringBuilder data, boolean quote) {
        if ( quote == true )
             data.append( String.format("'%s'", value) ) ;
        else data.append( String.format("%s", value) ) ;
        return( 0);
    }

    /**
     *
     * @param value
     * @param data
     * @param length
     * @param quote
     * @return
     */
    protected int getBoolean( boolean value, StringBuilder data ) {
        data.append( value ? "true" : "false" ) ;
        return( 0 ) ;
    }


    /**
     *
     * @param expression
     * @param remainder
     * @param error
     * @return
     */
    protected String parsingField(String expr, StringBuilder rem, StringBuilder error) {
        int     depth  = 0;
        int     stxIdx = 0;
        int     endIdx = 0;
        String  temp;

        do {
            if(expr == null || expr.equals("")) {
                error.delete(0, error.length());
                error.append("0"); return null;
            }
            expr = expr.trim();
            temp = expr;
            rem.delete(0, rem.length());
            for( endIdx = 0; endIdx < expr.length(); endIdx++) {
                if(temp.charAt(endIdx) == '{') {
                    ++depth; continue;
                }

                if(temp.charAt(endIdx) == '}') {
                    if( --depth < 0) break;
                }

                if(temp.charAt(endIdx) != ',' || depth > 0) continue;
                rem.append(expr.substring(endIdx + 1, expr.length()).trim());
                break;
            }

            if(depth > 0) {
                error.delete(0, error.length());
                error.append("-1"); return null;
	    }

            //remove bracket
            while(expr.charAt(stxIdx) == '{') {
                expr = expr.substring(stxIdx++).trim();
                for(--endIdx; stxIdx <= endIdx && expr.charAt(stxIdx) != '}'; --endIdx);
            }

            while( stxIdx < endIdx &&  temp.charAt(endIdx - 1) > 0 && temp.charAt(endIdx - 1) < 0x21)
                    --endIdx;
            temp = rem.toString();
        }while( endIdx < stxIdx && temp.length() > 0);
        if(expr.length() <= 0) {
            error.delete(0, error.length());
            error.append("0"); return null;
        }
        error.delete(0, error.length());
        error.append("0");
        return expr.substring(stxIdx, endIdx);
    }

    public int a2i( String string )
    {
    	int no = 0 ;
    	try{
    		no = Integer.parseInt(string);
    	}catch(Exception ex){
    		no = 0;
    	}
    	return no;
    }
	public boolean a2b( String value ) {
		if   ( value == null )	return false ;
		if   ( "".equals(value) )	return false ;

		/* check true */
		if   (  "true".equals( value ) )	return true ;
		if   (  "yes".equals( value ) )	return true ;
		/* check false */
		if   (  "false".equals( value ) )	return false ;
		if   (  "no".equals( value ) )		return false ;

		return (Integer( value )== 0 ? false : true) ;
	}

	public int Integer( String value ) {
		int no = 0 ;
		boolean sign ;
		if   ( value == null 	)	return 0 ;
		if   ( "".equals(value) )	return 0 ;
		try{
			no = Integer.parseInt(value);
		}catch(Exception ex){

		}
		return no ;
	}
	static public boolean comp_string(String str1,String str2){
		if(str1 == null && str2 == null) return false;
		if(str1 == null) return true;
		if(str1.equals(str2)) return false;
		return true;
	}
}
